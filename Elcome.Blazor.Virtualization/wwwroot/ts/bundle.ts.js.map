{"version":3,"sources":["wwwroot/ts/FlexibleVirtualize.ts","bundle.ts.js"],"names":["Virtualize","init","dotNetHelper","spacerBefore","spacerAfter","rootMargin","scrollContainer","findClosestScrollContainer","rangeBetweenSpacers","document","createRange","isValidTableElement","parentElement","style","display","intersectionObserver","IntersectionObserver","entries","forEach","entry","_a","isIntersecting","setStartAfter","setEndBefore","spacerSeparation","getBoundingClientRect","height","containerSize","rootBounds","target","invokeMethodAsync","intersectionRect","top","boundingClientRect","bottom","measureRows","offsetHeight","root","observe","mutationObserverBefore","createSpacerMutationObserver","mutationObserverAfter","observersByDotNetObjectId","id","getObserversMapEntry","spacer","observerOptions","attributes","mutationObserver","MutationObserver","mutations","observer","disconnect","unobserve","element","nextElementSibling","measurements","bounds","push","HTMLTableElement","HTMLTableSectionElement","dispose","observers","dispatcherObserversByDotNetIdPropname","Symbol","body","documentElement","getComputedStyle","overflowY","dotNetHelperDispatcher","dotNetHelperId"],"mappings":"AAKa,MAAAA,EAAa,CACxBC,KAwBF,SAAcC,EAAmCC,EAA2BC,EAA0BC,EAAa,IAIjH,MAAMC,EAAkBC,EAA2BJ,GAG7CK,EAAsBC,SAASC,cAEjCC,EAAoBP,EAAYQ,iBAClCT,EAAaU,MAAMC,QAAU,YAC7BV,EAAYS,MAAMC,QAAU,aAG9B,MAAMC,EAAuB,IAAIC,sBAuCjC,SAA8BC,GAC5BA,EAAQC,SAASC,ICnBT,IAAIC,EDoBV,IAAKD,EAAME,eACT,OAQFb,EAAoBc,cAAcnB,GAClCK,EAAoBe,aAAanB,GACjC,MAAMoB,EAAmBhB,EAAoBiB,wBAAwBC,OAC/DC,EAAgC,QAAhBP,EAAAD,EAAMS,kBAAU,IAAAR,OAAA,EAAAA,EAAEM,OAEpCP,EAAMU,SAAW1B,EACjBD,EAAa4B,kBAAkB,wBAAyBX,EAAMY,iBAAiBC,IAAMb,EAAMc,mBAAmBD,IAAKR,EAAkBG,EAAeR,EAAMc,mBAAmBC,OAASf,EAAMY,iBAAiBC,IAAKG,KAC3MhB,EAAMU,SAAWzB,GAAeA,EAAYgC,aAAe,GAIlElC,EAAa4B,kBAAkB,uBAAwBX,EAAMc,mBAAmBC,OAASf,EAAMY,iBAAiBG,OAAQV,EAAkBG,EAAeR,EAAMY,iBAAiBG,OAASf,EAAMc,mBAAmBD,IAAKG,ICnBrN,GAER,GD5C0E,CAC1EE,KAAM/B,EACND,WAAY,GAAGA,QAGjBU,EAAqBuB,QAAQnC,GAC7BY,EAAqBuB,QAAQlC,GAE7B,MAAMmC,EAAyBC,EAA6BrC,GACtDsC,EAAwBD,EAA6BpC,IAErDsC,0BAAEA,EAAyBC,GAAEA,GAAOC,EAAqB1C,GAO/D,SAASsC,EAA6BK,GAIpC,MAAMC,EAAkB,CAAEC,YAAY,GAChCC,EAAmB,IAAIC,kBAAiB,CAACC,EAA6BC,KACtExC,EAAoBkC,EAAOjC,iBAC7BuC,EAASC,aACTP,EAAOhC,MAAMC,QAAU,YACvBqC,EAASb,QAAQO,EAAQC,IAG3B/B,EAAqBsC,UAAUR,GAC/B9B,EAAqBuB,QAAQO,EAAO,IAKtC,OAFAG,EAAiBV,QAAQO,EAAQC,GAE1BE,CClBP,CDgDF,SAASb,IACP,IAAImB,EAAUnD,EAAaoD,mBAC3B,MAAMC,EAAyB,GAC/B,KAAOF,GAAWA,IAAYlD,GAAa,CACzC,MAAMqD,EAASH,EAAQ7B,wBACvB+B,EAAaE,KAAKD,EAAOzB,KACzBwB,EAAaE,KAAKD,EAAOvB,QACzBoB,EAAUA,EAAQC,kBCpBhB,CDsBJ,OAAOC,CCpBP,CDuBF,SAAS7C,EAAoB2C,GAC3B,OAAgB,OAAZA,IAIKA,aAAmBK,kBAA8C,KAA1BL,EAAQzC,MAAMC,SAA6C,UAA1BwC,EAAQzC,MAAMC,SACxFwC,aAAmBM,yBAAqD,KAA1BN,EAAQzC,MAAMC,SAA6C,oBAA1BwC,EAAQzC,MAAMC,QCtBpG,CDlDF4B,EAA0BC,GAAM,CAC9B5B,uBACAwB,yBACAE,wBAuEJ,EA3HEoB,QAwIF,SAAiB3D,GACf,MAAMwC,0BAAEA,EAAyBC,GAAEA,GAAOC,EAAqB1C,GACzD4D,EAAYpB,EAA0BC,GAExCmB,IACFA,EAAU/C,qBAAqBqC,aAC/BU,EAAUvB,uBAAuBa,aACjCU,EAAUrB,sBAAsBW,aAEhClD,EAAa2D,iBAENnB,EAA0BC,GAErC,GAlJMoB,EAAwCC,SAE9C,SAASzD,EAA2B+C,GAKlC,IAAKA,GAAWA,IAAY7C,SAASwD,MAAQX,IAAY7C,SAASyD,gBAChE,OAAO,KAKT,MAAwB,YAFVC,iBAAiBb,GAErBc,UACDd,EAGF/C,EAA2B+C,EAAQ1C,cAC5C,CAwGA,SAASgC,EAAqB1C,GCvB1B,IAAIkB,EDwBN,MAAMiD,EAAyBnE,EAA8B,gBACvDoE,EAAiBpE,EAAkB,IAGzC,OAF4D,QAA5DkB,EAAAiD,EAAuBN,UAAqC,IAAA3C,IAA5DiD,EAAuBN,GAA2C,CAAA,GAE3D,CACLrB,0BAA2B2B,EAAuBN,GAClDpB,GAAI2B,EAER,QCXStE","file":"bundle.ts.js","sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { DotNet } from '@microsoft/dotnet-js-interop';\r\n\r\nexport const Virtualize = {\r\n  init,\r\n  dispose,\r\n};\r\n\r\nconst dispatcherObserversByDotNetIdPropname = Symbol();\r\n\r\nfunction findClosestScrollContainer(element: HTMLElement | null): HTMLElement | null {\r\n  // If we recurse up as far as body or the document root, return null so that the\r\n  // IntersectionObserver observes intersection with the top-level scroll viewport\r\n  // instead of the with body/documentElement which can be arbitrarily tall.\r\n  // See https://github.com/dotnet/aspnetcore/issues/37659 for more about what this fixes.\r\n  if (!element || element === document.body || element === document.documentElement) {\r\n    return null;\r\n  }\r\n\r\n  const style = getComputedStyle(element);\r\n\r\n  if (style.overflowY !== 'visible') {\r\n    return element;\r\n  }\r\n\r\n  return findClosestScrollContainer(element.parentElement);\r\n}\r\n\r\nfunction init(dotNetHelper: DotNet.DotNetObject, spacerBefore: HTMLElement, spacerAfter: HTMLElement, rootMargin = 50): void {\r\n  // Overflow anchoring can cause an ongoing scroll loop, because when we resize the spacers, the browser\r\n  // would update the scroll position to compensate. Then the spacer would remain visible and we'd keep on\r\n  // trying to resize it.\r\n  const scrollContainer = findClosestScrollContainer(spacerBefore);\r\n  //(scrollContainer || document.documentElement).style.overflowAnchor = 'none'; // Disabled - we will instead disable anchoring on just the spacers and placeholders\r\n\r\n  const rangeBetweenSpacers = document.createRange();\r\n\r\n  if (isValidTableElement(spacerAfter.parentElement)) {\r\n    spacerBefore.style.display = 'table-row';\r\n    spacerAfter.style.display = 'table-row';\r\n  }\r\n\r\n  const intersectionObserver = new IntersectionObserver(intersectionCallback, {\r\n    root: scrollContainer,\r\n    rootMargin: `${rootMargin}px`,\r\n  });\r\n\r\n  intersectionObserver.observe(spacerBefore);\r\n  intersectionObserver.observe(spacerAfter);\r\n\r\n  const mutationObserverBefore = createSpacerMutationObserver(spacerBefore);\r\n  const mutationObserverAfter = createSpacerMutationObserver(spacerAfter);\r\n\r\n  const { observersByDotNetObjectId, id } = getObserversMapEntry(dotNetHelper);\r\n  observersByDotNetObjectId[id] = {\r\n    intersectionObserver,\r\n    mutationObserverBefore,\r\n    mutationObserverAfter,\r\n  };\r\n\r\n  function createSpacerMutationObserver(spacer: HTMLElement): MutationObserver {\r\n    // Without the use of thresholds, IntersectionObserver only detects binary changes in visibility,\r\n    // so if a spacer gets resized but remains visible, no additional callbacks will occur. By unobserving\r\n    // and reobserving spacers when they get resized, the intersection callback will re-run if they remain visible.\r\n    const observerOptions = { attributes: true };\r\n    const mutationObserver = new MutationObserver((mutations: MutationRecord[], observer: MutationObserver): void => {\r\n      if (isValidTableElement(spacer.parentElement)) {\r\n        observer.disconnect();\r\n        spacer.style.display = 'table-row';\r\n        observer.observe(spacer, observerOptions);\r\n      }\r\n\r\n      intersectionObserver.unobserve(spacer);\r\n      intersectionObserver.observe(spacer);\r\n    });\r\n\r\n    mutationObserver.observe(spacer, observerOptions);\r\n\r\n    return mutationObserver;\r\n  }\r\n\r\n  function intersectionCallback(entries: IntersectionObserverEntry[]): void {\r\n    entries.forEach((entry): void => {\r\n      if (!entry.isIntersecting) {\r\n        return;\r\n      }\r\n\r\n      // To compute the ItemSize, work out the separation between the two spacers. We can't just measure an individual element\r\n      // because each conceptual item could be made from multiple elements. Using getBoundingClientRect allows for the size to be\r\n      // a fractional value. It's important not to add or subtract any such fractional values (e.g., to subtract the 'top' of\r\n      // one item from the 'bottom' of another to get the distance between them) because floating point errors would cause\r\n      // scrolling glitches.\r\n      rangeBetweenSpacers.setStartAfter(spacerBefore);\r\n      rangeBetweenSpacers.setEndBefore(spacerAfter);\r\n      const spacerSeparation = rangeBetweenSpacers.getBoundingClientRect().height;\r\n      const containerSize = entry.rootBounds?.height;\r\n\r\n      if (entry.target === spacerBefore) {\r\n          dotNetHelper.invokeMethodAsync('OnSpacerBeforeVisible', entry.intersectionRect.top - entry.boundingClientRect.top, spacerSeparation, containerSize, entry.boundingClientRect.bottom - entry.intersectionRect.top, measureRows());\r\n      } else if (entry.target === spacerAfter && spacerAfter.offsetHeight > 0) {\r\n        // When we first start up, both the \"before\" and \"after\" spacers will be visible, but it's only relevant to raise a\r\n        // single event to load the initial data. To avoid raising two events, skip the one for the \"after\" spacer if we know\r\n        // it's meaningless to talk about any overlap into it.\r\n          dotNetHelper.invokeMethodAsync('OnSpacerAfterVisible', entry.boundingClientRect.bottom - entry.intersectionRect.bottom, spacerSeparation, containerSize, entry.intersectionRect.bottom - entry.boundingClientRect.top, measureRows());\r\n      }\r\n    });\r\n  }\r\n\r\n  function measureRows(): number[] {\r\n    let element = spacerBefore.nextElementSibling;\r\n    const measurements: number[] = [];\r\n    while (element && element !== spacerAfter) {\r\n      const bounds = element.getBoundingClientRect();\r\n      measurements.push(bounds.top);\r\n      measurements.push(bounds.bottom);\r\n      element = element.nextElementSibling;\r\n    }\r\n    return measurements;\r\n  }\r\n\r\n  function isValidTableElement(element: HTMLElement | null): boolean {\r\n    if (element === null) {\r\n      return false;\r\n    }\r\n\r\n    return ((element instanceof HTMLTableElement && element.style.display === '') || element.style.display === 'table')\r\n      || ((element instanceof HTMLTableSectionElement && element.style.display === '') || element.style.display === 'table-row-group');\r\n  }\r\n}\r\n\r\nfunction getObserversMapEntry(dotNetHelper: DotNet.DotNetObject): { observersByDotNetObjectId: {[id: number]: any }, id: number } {\r\n  const dotNetHelperDispatcher = dotNetHelper['_callDispatcher'];\r\n  const dotNetHelperId = dotNetHelper['_id'];\r\n  dotNetHelperDispatcher[dispatcherObserversByDotNetIdPropname] ??= { };\r\n\r\n  return {\r\n    observersByDotNetObjectId: dotNetHelperDispatcher[dispatcherObserversByDotNetIdPropname],\r\n    id: dotNetHelperId,\r\n  };\r\n}\r\n\r\nfunction dispose(dotNetHelper: DotNet.DotNetObject): void {\r\n  const { observersByDotNetObjectId, id } = getObserversMapEntry(dotNetHelper);\r\n  const observers = observersByDotNetObjectId[id];\r\n\r\n  if (observers) {\r\n    observers.intersectionObserver.disconnect();\r\n    observers.mutationObserverBefore.disconnect();\r\n    observers.mutationObserverAfter.disconnect();\r\n\r\n    dotNetHelper.dispose();\r\n\r\n    delete observersByDotNetObjectId[id];\r\n  }\r\n}\r\n",null]}